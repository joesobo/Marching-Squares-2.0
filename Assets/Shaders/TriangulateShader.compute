#pragma kernel CSMain

struct Triangle {
  float2 vertexA;
  float2 vertexB;
  float2 vertexC;
  float red;
  float green;
  float blue;
};

struct Color {
  float red;
  float green;
  float blue;
};

RWStructuredBuffer<float3> _Vertices;
AppendStructuredBuffer<Triangle> _Triangles;
RWStructuredBuffer<int> _States;
uint _VoxelResolution;
uint _ChunkResolution;

int2 GetUV (int3 id) {
  return id.xy;
}

int indexFromCoord(int x, int y) {
  return y * _VoxelResolution + x + y;
}

void addTriangle(float2 aMidPoint, float2 bMidPoint, float2 cMidPoint, Color col) {
  Triangle tri;
  tri.vertexA = aMidPoint;
  tri.vertexB = bMidPoint;
  tri.vertexC = cMidPoint;
  tri.red = col.red;
  tri.green = col.green;
  tri.blue = col.blue;
  _Triangles.Append(tri);
}


void GetCornerStates(int2 uv, out int cornerStates[4]) {
  cornerStates[0] = _States[indexFromCoord(uv.x, uv.y)];
  cornerStates[1] = _States[indexFromCoord(uv.x + 1, uv.y)];
  cornerStates[2] = _States[indexFromCoord(uv.x, uv.y + 1)];
  cornerStates[3] = _States[indexFromCoord(uv.x + 1, uv.y + 1)];
}

bool isMultiMaterial(int2 uv) {
  int squareCornerStates[4];
  GetCornerStates(uv, squareCornerStates);

  int aMidPoint = squareCornerStates[0];
  int bMidPoint = squareCornerStates[1];
  int cMidPoint = squareCornerStates[2];
  int dMidPoint = squareCornerStates[3];

  if (aMidPoint == 0 && bMidPoint == 0 && cMidPoint == 0 && dMidPoint == 0) {
    return false;
  }

  float value = aMidPoint > 0 ? aMidPoint : bMidPoint > 0 ? bMidPoint : cMidPoint > 0 ? cMidPoint : dMidPoint;
  if ((aMidPoint == value || aMidPoint == 0) && (bMidPoint == value || bMidPoint == 0) && (cMidPoint == value || cMidPoint == 0) && (dMidPoint == value || dMidPoint == 0)) {
    return false;
  }

  return true;
}

Color colorByState(float state) {
  Color col;
  col.red = state / 255.0;
  col.blue = 0;
  col.green = 0;

  return col;
}

int GetCellType(int2 uv) {
  int squareCornerStates[4];
  GetCornerStates(uv, squareCornerStates);

  // find voxel cell type based on corner states
  int cellType = 0;

  if (squareCornerStates[0] > 0) cellType |= 1;
  if (squareCornerStates[1] > 0) cellType |= 2;
  if (squareCornerStates[2] > 0) cellType |= 4;
  if (squareCornerStates[3] > 0) cellType |= 8;

  // handle extra states for multi-material voxels
  if(cellType >= 15) {
    if (squareCornerStates[0] != squareCornerStates[1] && squareCornerStates[0] != squareCornerStates[2] && squareCornerStates[0] != squareCornerStates[3] && squareCornerStates[1] == squareCornerStates[2] && squareCornerStates[1] == squareCornerStates[3]) {
    cellType = 16;
    }
    else if (squareCornerStates[1] != squareCornerStates[0] && squareCornerStates[1] != squareCornerStates[2] && squareCornerStates[1] != squareCornerStates[3] && squareCornerStates[0] == squareCornerStates[2] && squareCornerStates[0] == squareCornerStates[3]) {
    cellType = 17;
    }
    else if (squareCornerStates[2] != squareCornerStates[3] && squareCornerStates[2] != squareCornerStates[0] && squareCornerStates[2] != squareCornerStates[1] && squareCornerStates[0] == squareCornerStates[1] && squareCornerStates[0] == squareCornerStates[3]) {
    cellType = 18;
    }
    else if (squareCornerStates[3] != squareCornerStates[0] && squareCornerStates[3] != squareCornerStates[1] && squareCornerStates[3] != squareCornerStates[2] && squareCornerStates[0] == squareCornerStates[1] && squareCornerStates[0] == squareCornerStates[2]) {
    cellType = 19;
    }
    else if (squareCornerStates[0] != squareCornerStates[1] && squareCornerStates[2] != squareCornerStates[1] && squareCornerStates[1] == squareCornerStates[3]) {
    cellType = 20;
    }
    else if (squareCornerStates[1] != squareCornerStates[0] && squareCornerStates[3] != squareCornerStates[0] && squareCornerStates[0] == squareCornerStates[2]) {
    cellType = 21;
    }
  }

  return cellType;
}

void GetColors(int2 uv, out Color colors[4]) {
  int squareCornerStates[4];
  GetCornerStates(uv, squareCornerStates);

  colors[0] = colorByState(squareCornerStates[0]);
  colors[1] = colorByState(squareCornerStates[1]);
  colors[2] = colorByState(squareCornerStates[2]);
  colors[3] = colorByState(squareCornerStates[3]);
}

void GetCorners(int2 uv, out float2 corners[4]) {
  float res = float(_VoxelResolution * _ChunkResolution);

  corners[0] = float2(uv) / res;
  corners[1] = float2(uv.x + 1, uv.y) / res;
  corners[2] = float2(uv.x + 1, uv.y + 1) / res;
  corners[3] = float2(uv.x, uv.y + 1) / res;
}

void GetMidPoints(int2 uv, float resLen, float2 offset, out int midpoints[4]) {
  float2 corners[4];
  GetCorners(uv, corners);

  midpoints[0] = float2(corners[0].x + resLen * 0.5, corners[0].y) + offset;
  midpoints[1] = float2(corners[0].x + resLen, corners[0].y + resLen * 0.5) + offset;
  midpoints[2] = float2(corners[0].x + resLen * 0.5, corners[0].y + resLen) + offset;
  midpoints[3] = float2(corners[0].x, corners[0].y + resLen * 0.5) + offset;
}

void GetInnerPoints(int2 uv, float resLen, float2 offset, out float2 innerPoints[4]) {
  float2 corners[4];
  GetCorners(uv, corners);

  innerPoints[0] = float2(corners[0].x + resLen * 0.25, corners[0].y + resLen * 0.25) + offset;
  innerPoints[1] = float2(corners[0].x + resLen * 0.75, corners[0].y + resLen * 0.25) + offset;
  innerPoints[2] = float2(corners[0].x + resLen * 0.75, corners[0].y + resLen * 0.75) + offset;
  innerPoints[3] = float2(corners[0].x + resLen * 0.25, corners[0].y + resLen * 0.75) + offset;
}

void GetCornersWithOffset(int2 uv, float2 offset, out int offsetCorners[4]) {
  float2 corners[4];
  GetCorners(uv, corners);

  offsetCorners[0] = corners[0] + offset;
  offsetCorners[1] = corners[1] + offset;
  offsetCorners[2] = corners[2] + offset;
  offsetCorners[3] = corners[3] + offset;
}

void TriangulateMultiMaterial(float2 uv, float resLen, float2 offset) {
  int cellType = GetCellType(uv);

  Color color[4];
  GetColors(uv, color);

  int midpoints[4];
  GetMidPoints(uv, resLen, offset, midpoints);
  float2 aMidPoint = midpoints[0];
  float2 bMidPoint = midpoints[1];
  float2 cMidPoint = midpoints[2];
  float2 dMidPoint = midpoints[3];

  int offsetCorners[4];
  GetCornersWithOffset(uv, offset, offsetCorners);
  float2 ACorner = offsetCorners[0];
  float2 BCorner = offsetCorners[1];
  float2 CCorner = offsetCorners[2];
  float2 DCorner = offsetCorners[3];

  float2 innerPoints[4];
  GetInnerPoints(uv, resLen, offset, innerPoints);
  float2 innerA = innerPoints[0];
  float2 innerB = innerPoints[1];
  float2 innerC = innerPoints[2];
  float2 innerD = innerPoints[3];

  float2 center = float2(ACorner.x + resLen * 0.5, ACorner.y + resLen * 0.5) + offset;

  switch (cellType) {
    case 1:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      break;
    case 2:
      addTriangle(bMidPoint, BCorner, aMidPoint, color[1]);
      break;
    case 3:
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(aMidPoint, center, BCorner, color[1]);
      addTriangle(center, bMidPoint, BCorner, color[1]);
      break;
    case 4:
      addTriangle(cMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 5:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      addTriangle(cMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 6:
      addTriangle(BCorner, aMidPoint, center, color[1]);
      addTriangle(center, bMidPoint, BCorner, color[1]);
      addTriangle(bMidPoint, center, cMidPoint, color[2]);
      addTriangle(cMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 7:
      addTriangle(ACorner, dMidPoint, aMidPoint, color[0]);
      addTriangle(dMidPoint, center, aMidPoint, color[0]);
      addTriangle(dMidPoint, innerD, center, color[0]);
      addTriangle(BCorner, aMidPoint, center, color[1]);
      addTriangle(BCorner, center, bMidPoint, color[1]);
      addTriangle(bMidPoint, center, cMidPoint, color[2]);
      addTriangle(bMidPoint, cMidPoint, CCorner, color[2]);
      addTriangle(center, innerD, cMidPoint, color[2]);
      break;
    case 8:
      addTriangle(cMidPoint, dMidPoint, DCorner, color[3]);
      break;
    case 9:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(center, ACorner, dMidPoint, color[0]);
      addTriangle(center, dMidPoint, cMidPoint, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 10:
      addTriangle(bMidPoint, BCorner, aMidPoint, color[1]);
      addTriangle(cMidPoint, dMidPoint, DCorner, color[3]);
      break;
    case 11:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      addTriangle(aMidPoint, dMidPoint, center, color[0]);
      addTriangle(BCorner, aMidPoint, center, color[1]);
      addTriangle(BCorner, center, bMidPoint, color[1]);
      addTriangle(bMidPoint, center, innerC, color[1]);
      addTriangle(center, dMidPoint, DCorner, color[3]);
      addTriangle(center, DCorner, cMidPoint, color[3]);
      addTriangle(center, cMidPoint, innerC, color[3]);
      break;
    case 12:
      addTriangle(bMidPoint, center, CCorner, color[2]);
      addTriangle(CCorner, center, cMidPoint, color[2]);
      addTriangle(cMidPoint, center, dMidPoint, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 13:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      addTriangle(aMidPoint, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, center, innerB, color[0]);
      addTriangle(innerB, center, bMidPoint, color[2]);
      addTriangle(bMidPoint, center, cMidPoint, color[2]);
      addTriangle(bMidPoint, cMidPoint, CCorner, color[2]);
      addTriangle(center, dMidPoint, DCorner, color[3]);
      addTriangle(center, DCorner, cMidPoint, color[3]);
      break;
    case 14:
      addTriangle(innerA, center, aMidPoint, color[1]);
      addTriangle(BCorner, aMidPoint, center, color[1]);
      addTriangle(BCorner, center, bMidPoint, color[1]);
      addTriangle(bMidPoint, center, cMidPoint, color[2]);
      addTriangle(bMidPoint, cMidPoint, CCorner, color[2]);
      addTriangle(center, dMidPoint, DCorner, color[3]);
      addTriangle(center, DCorner, cMidPoint, color[3]);
      addTriangle(center, innerA, dMidPoint, color[3]);
      break;
    case 15:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[1]);
      addTriangle(center, CCorner, bMidPoint, color[2]);
      addTriangle(center, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 16:
      addTriangle(ACorner, dMidPoint, aMidPoint, color[0]);
      addTriangle(aMidPoint, dMidPoint, center, color[1]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[1]);
      addTriangle(center, CCorner, bMidPoint, color[2]);
      addTriangle(center, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 17:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[0]);
      addTriangle(center, CCorner, bMidPoint, color[2]);
      addTriangle(center, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 18:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[1]);
      addTriangle(bMidPoint, center, cMidPoint, color[0]);
      addTriangle(bMidPoint, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 19:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[1]);
      addTriangle(center, CCorner, bMidPoint, color[2]);
      addTriangle(center, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[0]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 20:
      addTriangle(ACorner, dMidPoint, aMidPoint, color[0]);
      addTriangle(aMidPoint, dMidPoint, center, color[1]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[1]);
      addTriangle(bMidPoint, center, cMidPoint, color[1]);
      addTriangle(bMidPoint, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[3]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
    case 21:
      addTriangle(ACorner, center, aMidPoint, color[0]);
      addTriangle(ACorner, dMidPoint, center, color[0]);
      addTriangle(aMidPoint, bMidPoint, BCorner, color[1]);
      addTriangle(aMidPoint, center, bMidPoint, color[2]);
      addTriangle(center, CCorner, bMidPoint, color[2]);
      addTriangle(center, cMidPoint, CCorner, color[2]);
      addTriangle(dMidPoint, cMidPoint, center, color[2]);
      addTriangle(dMidPoint, DCorner, cMidPoint, color[3]);
      break;
  }
}

void TriangulateNormal(float2 uv, float resLen, float2 offset) {
  int cellType = GetCellType(uv);

  Color color[4];
  GetColors(uv, color);

  int midpoints[4];
  GetMidPoints(uv, resLen, offset, midpoints);
  float2 aMidPoint = midpoints[0];
  float2 bMidPoint = midpoints[1];
  float2 cMidPoint = midpoints[2];
  float2 dMidPoint = midpoints[3];

  int offsetCorners[4];
  GetCornersWithOffset(uv, offset, offsetCorners);
  float2 ACorner = offsetCorners[0];
  float2 BCorner = offsetCorners[1];
  float2 CCorner = offsetCorners[2];
  float2 DCorner = offsetCorners[3];

  switch (cellType) {
    case 1:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      break;
    case 2:
      addTriangle(bMidPoint, BCorner, aMidPoint, color[1]);
      break;
    case 3:
      addTriangle(BCorner, ACorner, dMidPoint, color[0]);
      addTriangle(dMidPoint, bMidPoint, BCorner, color[1]);
      break;
    case 4:
      addTriangle(cMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 5:
      addTriangle(aMidPoint, ACorner, dMidPoint, color[0]);
      addTriangle(cMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 6:
      addTriangle(BCorner, cMidPoint, CCorner, color[2]);
      addTriangle(aMidPoint, cMidPoint, BCorner, color[1]);
      break;
    case 7:
      addTriangle(dMidPoint, BCorner, ACorner, color[0]);
      addTriangle(dMidPoint, cMidPoint, BCorner, color[1]);
      addTriangle(cMidPoint, CCorner, BCorner, color[2]);
      break;
    case 8:
      addTriangle(cMidPoint, dMidPoint, DCorner, color[3]);
      break;
    case 9:
      addTriangle(DCorner, cMidPoint, ACorner, color[3]);
      addTriangle(cMidPoint, aMidPoint, ACorner, color[0]);
      break;
    case 10:
      addTriangle(bMidPoint, BCorner, aMidPoint, color[1]);
      addTriangle(cMidPoint, dMidPoint, DCorner, color[3]);
      break;
    case 11:
      addTriangle(ACorner, bMidPoint, BCorner, color[1]);
      addTriangle(ACorner, cMidPoint, bMidPoint, color[0]);
      addTriangle(ACorner, DCorner, cMidPoint, color[3]);
      break;
    case 12:
      addTriangle(DCorner, CCorner, dMidPoint, color[3]);
      addTriangle(dMidPoint, CCorner, bMidPoint, color[2]);
      break;
    case 13:
      addTriangle(ACorner, DCorner, aMidPoint, color[0]);
      addTriangle(aMidPoint, DCorner, bMidPoint, color[3]);
      addTriangle(bMidPoint, DCorner, CCorner, color[2]);
      break;
    case 14:
      addTriangle(DCorner, CCorner, dMidPoint, color[3]);
      addTriangle(dMidPoint, CCorner, aMidPoint, color[2]);
      addTriangle(aMidPoint, CCorner, BCorner, color[1]);
      break;
    case 15:
      addTriangle(ACorner, CCorner, BCorner, color[1]);
      addTriangle(ACorner, DCorner, CCorner, color[3]);
      break;
  }
}

void TriangulateCellRows(int2 uv) {
  // Skip last row/column of voxel points (not enough points for aMidPoint square)
  if (uv.x >= _VoxelResolution || uv.y >= _VoxelResolution) {
    return;
  }

  float res = float(_VoxelResolution * _ChunkResolution);
  float resLen = (1.0 / res);
  float2 offset = float2(resLen * 0.5, resLen * 0.5);

  if (isMultiMaterial(uv)) {
    TriangulateMultiMaterial(uv, resLen, offset);
  } else {
    TriangulateNormal(uv, resLen, offset);
  }
}

[numthreads(8,8,1)]
void CSMain (int3 id : SV_DispatchThreadID) {
  int2 uv = GetUV(id);
  TriangulateCellRows(uv);
}
